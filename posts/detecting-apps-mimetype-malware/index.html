<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Detecting analysts before installing the malware (IE) | BrokenBrowser - Fun with browser vulnerabilities</title>
<meta name="keywords" content="">
<meta name="description" content="With the help of a beautiful piece of code, malware authors can detect installed applications straight from within the browser and serve the bad bits only to unsavvy users. In other words, attackers target regular users by detecting specific analysts applications (like Fiddler) and serving their harmful program to users that do not have those apps installed. Essentially, their goal is to keep their malware under the radars for a longer period of time.">
<meta name="author" content="magicmac">
<link rel="canonical" href="/posts/detecting-apps-mimetype-malware/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.6a98292fb8fa8cf0f3ba4042d4b75515c04267550f3ad49ff6271b5af9562443.css" integrity="sha256-apgpL7j6jPDzukBC1LdVFcBCZ1UPOtSf9icbWvlWJEM=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Detecting analysts before installing the malware (IE)" />
<meta property="og:description" content="With the help of a beautiful piece of code, malware authors can detect installed applications straight from within the browser and serve the bad bits only to unsavvy users. In other words, attackers target regular users by detecting specific analysts applications (like Fiddler) and serving their harmful program to users that do not have those apps installed. Essentially, their goal is to keep their malware under the radars for a longer period of time." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/detecting-apps-mimetype-malware/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-09-19T04:30:26-03:00" />
<meta property="article:modified_time" content="2016-09-19T04:30:26-03:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Detecting analysts before installing the malware (IE)"/>
<meta name="twitter:description" content="With the help of a beautiful piece of code, malware authors can detect installed applications straight from within the browser and serve the bad bits only to unsavvy users. In other words, attackers target regular users by detecting specific analysts applications (like Fiddler) and serving their harmful program to users that do not have those apps installed. Essentially, their goal is to keep their malware under the radars for a longer period of time."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/posts/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Detecting analysts before installing the malware (IE)",
      "item": "/posts/detecting-apps-mimetype-malware/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Detecting analysts before installing the malware (IE)",
  "name": "Detecting analysts before installing the malware (IE)",
  "description": "With the help of a beautiful piece of code, malware authors can detect installed applications straight from within the browser and serve the bad bits only to unsavvy users. In other words, attackers target regular users by detecting specific analysts applications (like Fiddler) and serving their harmful program to users that do not have those apps installed. Essentially, their goal is to keep their malware under the radars for a longer period of time.",
  "keywords": [
    
  ],
  "articleBody": "With the help of a beautiful piece of code, malware authors can detect installed applications straight from within the browser and serve the bad bits only to unsavvy users. In other words, attackers target regular users by detecting specific analysts applications (like Fiddler) and serving their harmful program to users that do not have those apps installed. Essentially, their goal is to keep their malware under the radars for a longer period of time.\nToday we are going find a variation for CVE-2016-3351 that Microsoft patched last Tuesday, but before getting started, let me tell you that I couldn’t even begin this without the continued help of Jérôme Segura from MalwareBytes. Also, later on the issue I received help from Kafeine, Brooks Li, and Joseph C Chen either directly or out of their impressive research on AdGholas. Finally, I’d like to thank Eric Lawrence and David Ross because without their constant help and support, blogging for me wouldn’t be possible.\nUntil last week, I have no idea of the details on the technique that follows. I knew like everyone else that AdGholas was evading analysts but I had no idea how, and no free time to research about it. However, I was still curious but Brooks Li gently told me that he couldn’t share the PoC until Microsoft released the patch. So, I simply forgot about this until last Tuesday, when I saw that my PC was updating. Ohh!! The mimeType bug! So I requested the PoC from Brooks and he told me that they have published the solution, right here. The article was impressive, but what caught my attention was the image below (yellow is mine).\nThis is beautiful! How simple and elegant! Let’s convert it into something easier for our eyes:\nanchor = document.createElement(\"A\"); anchor.href = \".saz\"; alert(anchor.mimeType); // returns Fiddler Session Archive Impressive! This returns Fiddler Session Archive, so attackers will quickly know if the user has Fiddler installed! Of course this can be done with other extensions and if you are curious, open the registry and navigate to Computer\\HKEY_CLASSES_ROOT. There they are.\nI was really amazed by the simplicity of the code, extremely beautiful even being malware, so I created a simple function based on it for easier testing. Of course that beauty will stop working after updating our Windows, but who will deny its elegance anyway? Five minutes later my PC was updated and I was excited to see the same code failing after the patch. Predictably, it failed. It now returns “undefined” when we retrieve mimeType property of an anchor element.\nJust as a quick preview of what’s coming, take a look at the before and after patch pictures. If it were the ad of a weight loss product we would be impressed by the change: the code has really been reduced! We don’t need to analyze anything at this point, just watch how the code was brutally trimmed. I prefer the elegance of the malware authors, even if malware. And by the way, attackers won’t get discouraged by this trim, they will instead try to find an alternative.\nBug patched: Finding an Alternative So the patch is brutal but ideas start flowing. Why don’t we find an alternative route (aka variation) like real attackers do? It might be possible and worth a few minutes. So we need to get the unpatched code (from mshtml.dll in this case) and find what’s the binary function that gets hit when we access the anchor mimeType. Then, we need to find a way to call that same code using a different path.\nThe flow below shows what we guess before even disassembling mshtml. We know for sure that the yellow path exists, but we want to know if there are alternatives (red) to it. How can we do that? First, we should find the exact binary code that retrieves the mimeType, and then, uncover other references to it. The red path is a speculation, something that could or could not be there. But we will give it a try and get the answer pretty quick.\nThere is a path from the JavaScript anchor.mimeType to a binary function (compiled code) that retrieves the mimeType. Our goal is to find the binary code that retrieves the mimeType and uncover every reference to it. The red paths show references that we suspect might exist, and even if this is just a guess, it’s worth our time because it can be done in a couple of minutes.\nWe will be using IDA Free for this task but there are many tools to achieve the same thing. In fact, once we get familiar with IE/Edge function names, we will go faster with a live debugger like WinDBG or even a quick disassembler like Hiew (with symbols). But today we will assume that IE is a strange object for us and we don’t know anything about it.\nSetup IDA Free Note: I will be posting soon how to setup IDA Free with public symbols so you can do exactly as we do here. But in the meantime I pasted plain-text instructions here so you can get started!\nFinding the Interesting Code Let’s drop in IDA the binary that makes Internet Explorer tick: mshtml.dll. If you are not familiar with disassemblers, just follow as much as you can. This will be pretty basic and we can safely forget about opcodes today. Ready for the adventure? Remember: no Assembler required, just a bit of mind-stretching on ourselves.\nFirst Goal: find the binary code that reveals the mimeType information.\nWe know that in JavaScript, anchor.mimeType retrieves the information that we want, so let’s go straight to the Strings Tab in IDA and search for “mimeType”. We want to see what’s the code that references it. The first two matches clearly have nothing to do with our goal: MSMimeTypesCollections, MSMimeTypesCollectionsPrototype. The third one is MimeType but we want one that starts with a lowercase m. The next two are MimeTypeArray are MimeTypeArrayPrototype which again are not what we need. Next one seems to be what we are searching for! This is the first real match of “mimeType”.\nDouble clicking on that string takes us to the binary code tab (IDA-ViewA) which includes data references.\nIDA labels everything it can to help us with the analysis. In this case the “mimeType” string pointer was named aMimetype_2 as shown above (1). At the right (2) we can see the code that uses this string, but in order to see the complete list we should click on the label aMimeType_2 and press the “X” so a popUp will open with every line of code referencing this string. How convenient! (We know there are more references because of the three dots (3) at the right).\nNow check out the popUp below. We have three references and the middle one seems to be the one that we need. Don’t you think so? We want to find first what’s the binary code that is hit when we access anchor.mimeType and the function names below, make sense to me.\nRemember, we are not trying to read opcodes here, just flowing with things that make sense according to the names that we know. There are more orthodox ways to achieve this but we are investing less than five minutes, just an educated guess.\nTake a look at the names below. To me, the first one makes sense CHTMLAnchorElement::Trampoline\\_Get\\_mimeType. True that the “Trampoline” part does not look familiar, but it does not prevent us to keep going and see if we find what we need.\nEntering there (double click) takes us to a longer piece of code, but we shouldn’t lose our target: mimeType. Don’t read opcodes, just find “mimeType”.\nEven if confusing at first sight, if we do as we said and ignore the opcodes, it’s obvious what’s the function that we should follow, right? And if we double click on CAnchorElement::get_mimeType, we will end up in the code below.\nAgain a bit longer than we would like, but we have CHyperlink_get_href first and a few lines below GetFileTypeInfo. It somewhat rings to me. First getting the href and then calling GetFileTypeInfo. I totally know this is a speculation but when we are analyzing regular code, educated guesses work most of the time. If we were reversing malware this would be harder, however, IE does not play tricks on us. Let’s go to GetFileTypeInfo and see what we have there.\nWe found our code! The call to SHGetFileInfoW seems pretty obvious to me, but we can always Google it and see what it does. This seems to be the code that retrieves the mimeType, but remember we are speculating here. Let’s see if this 3 minute speculation gives us some dividends.\nFinding References (to discover alternative paths) Click once at the top, over “GetFileTypeInfo” and press the “X” to display all references. Remember: we want to see if there are other ways to hit this code.\n### Trying JavaScript Code\nBingo! It seems that this code is hit twice by CDocument::get_mimeType, another one by CImgElement::get_mimeType and of course the one that we knew from the beginning, CAnchorElement::get_mimeType. CDocument looks like the document object to me and CImgElement seems to be the Image object or IMG HTML Tag. Of course we are speculating, but what do we lose by going right now to the browser and testing document.mimeType and Image.mimeType? I didn’t even know (or remember) that those properties existed.\nRayos y centellas, Batman! It worked! Let’s see what happens with the document object. Will this work?\nSo now that we learned about these properties, we can complete the original flow, just like this:\nWe still don’t know if the anchorElement has other paths to the same code, but why bother? We are working with the unpatched binary and as we’ve seen at the beginning, the patched one has been seriously trimmed. In fact, a quick analysis reveals that anchorElement.mimeType and GetFileTypeInfo are not connected anymore. By “quick analysis” I mean pressing the “X” over the GetFileTypeInfo function inside IDA on the patched file. So, the updated flow really looks like this:\n### Playing with Code Alternatives\nWe know that the anchorElement is useless for our goal but the image and document objects have chances. Well, thinking for a moment, images can’t render things other than images, so it will be better to first try using the document object which is capable of rendering images, xml, html, and more. Also, if we are going to render different content-types in a document, better not to use the one where we run our script, right? If we do, our script will be unloaded by the new content. Let’s create an iframe and play with its document.\nWe try to render a .saz (Fiddler) file right inside the iframe.\niframe = document.createElement(\"iframe\"); iframe.src = \"saz.saz\"; // Load a saz file document.body.appendChild(iframe); Damn! IE tries to download the file and throws this warning!\nNot acceptable. Attackers are very cautious with these things. They will get caught immediately with a code like that. And in any case, it does not work: when we try to get the document.mimeType of that iframe, it returns “Chrome HTML Document”. We need to change the URL of that iframe without warnings and fool IE to think that a saz file has been rendered. We will set the location of the iframe without really changing the content of the document. This can be done with history.pushState or history.replaceState. Let’s continue with the same iframe.\niframe.contentWindow.history.pushState(\"\",\"\",\"saz.saz\"); alert(iframe.contentDocument.mimeType); It seems that we have it, right? Wrong! We’ve been lucky because the saz file was previously downloaded and cached, although not rendered because it has a saz extension. When IE requests data from a URL, it first tries to guess its content type using different mechanisms, and the last of them is the file extension. In this case we are not even retrieving a valid saz file, the web-server response was a default HTTP Status Code 200 with default Content-Type: application/octet-stream but IE ended up guessing that it’s a Fiddler file because of its extension, however, it needed to download the file first.\nBuilding a working Proof of Concept So what can we do to download the file in advance without warnings? Well, there are a zillion ways, but let’s use the most primitive one which was used in the past to cache roll-over images: the Image object. Let’s build a proof of concept but this time caching the saz in advance and using replaceState instead of pushState (it’s cleaner and doesn’t add URLs in the history object).\nimg = new Image(); img.src = \"saz.saz\"; // HTTP 200, any length and content-type // The saz is precached. Let's create the iframe. iframe = document.createElement(\"iframe\"); // Load anything inside it because about:blank does not work with replaceState. iframe.src = \"/favicon.ico\"; document.body.appendChild(iframe); // Set the location of the iframe to the saz file iframe.contentWindow.history.replaceState(\"\", \"\", img.src); // Bingo! alert(iframe.contentDocument.mimeType); Update: variation patched on 2016-11-08. [ Test it Live on IE ] [ Download the Files ] If you are a Linux user, just watch the video below:\nHave a nice day, fellow bug hunter! If you have questions please ping me at magicmac2000.\n",
  "wordCount" : "2202",
  "inLanguage": "en",
  "datePublished": "2016-09-19T04:30:26-03:00",
  "dateModified": "2016-09-19T04:30:26-03:00",
  "author":{
    "@type": "Person",
    "name": "magicmac"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/posts/detecting-apps-mimetype-malware/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "BrokenBrowser - Fun with browser vulnerabilities",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="BrokenBrowser - Fun with browser vulnerabilities (Alt + H)">BrokenBrowser - Fun with browser vulnerabilities</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Detecting analysts before installing the malware (IE)
    </h1>
    <div class="post-meta"><span title='2016-09-19 04:30:26 -0300 -03'>September 19, 2016</span>&nbsp;·&nbsp;magicmac

</div>
  </header> 
  <div class="post-content"><p>With the help of a beautiful piece of code, malware authors can detect installed applications straight from within the browser and serve the bad bits only to unsavvy users. In other words, attackers target regular users by detecting specific analysts applications (like <a href="http://www.telerik.com/fiddler">Fiddler</a>) and serving their harmful program to users that do not have those apps installed. Essentially, their goal is to keep their malware under the radars for a longer period of time.</p>
<p>Today we are going find a variation for <a href="https://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-3351">CVE-2016-3351</a> that Microsoft patched last Tuesday, but before getting started, let me tell you that I couldn’t even begin this without the continued help of <a href="https://twitter.com/jeromesegura">Jérôme Segura</a> from MalwareBytes. Also, later on the issue I received help from <a href="https://twitter.com/kafeine">Kafeine</a>, <a href="https://twitter.com/brooks_li">Brooks Li</a>, and <a href="https://twitter.com/Jspchc">Joseph C Chen</a> either directly or out of their <a href="https://www.proofpoint.com/us/threat-insight/post/massive-adgholas-malvertising-campaigns-use-steganography-and-file-whitelisting-to-hide-in-plain-sight">impressive research on AdGholas</a>. Finally, I’d like to thank <a href="https://twitter.com/ericlaw">Eric Lawrence</a> and <a href="https://twitter.com/randomdross">David Ross</a> because without their constant help and support, blogging for me wouldn’t be possible.</p>
<p>Until last week, I have no idea of the details on the technique that follows. I knew like everyone else that <a href="https://www.proofpoint.com/us/threat-insight/post/massive-adgholas-malvertising-campaigns-use-steganography-and-file-whitelisting-to-hide-in-plain-sight">AdGholas was evading analysts</a> but I had no idea how, and no free time to research about it. However, I was still curious but Brooks Li gently told me that he couldn’t share the PoC until Microsoft released the patch. So, I simply forgot about this until last Tuesday, when I saw that my PC was updating. Ohh!! The mimeType bug! So I requested the PoC from Brooks and he told me that they have published the solution, <a href="https://www.proofpoint.com/us/threat-insight/post/Microsoft-Patches-Zero-Day-Exploited-By-AdGholas-GooNky-Malvertising">right here</a>. The article was impressive, but what caught my attention was the image below (yellow is mine).</p>
<p><img loading="lazy" src="/2016/09/01-proofpoint-pic.png" alt="Elegant Code"  />
</p>
<p>This is beautiful! How simple and elegant! Let’s convert it into something easier for our eyes:</p>
<pre tabindex="0"><code>anchor = document.createElement(&#34;A&#34;);
anchor.href = &#34;.saz&#34;;
alert(anchor.mimeType);
// returns Fiddler Session Archive
</code></pre><p><img loading="lazy" src="/2016/09/02-proof-fiddler.png" alt="Fiddler Archive"  />
</p>
<p>Impressive! This returns <em>Fiddler Session Archive,</em> so attackers will quickly know if the user has Fiddler installed! Of course this can be done with other extensions and if you are curious, open the registry and navigate to <em>Computer\HKEY_CLASSES_ROOT</em>. There they are.</p>
<p>I was really amazed by the simplicity of the code, extremely beautiful even being malware, so I created a <a href="http://pastebin.com/8ezKBcVT">simple function based on it</a> for easier testing. Of course that beauty will stop working after updating our Windows, but who will deny its elegance anyway? Five minutes later my PC was updated and I was excited to see the same code failing after the patch. Predictably, it failed. It now returns “undefined” when we retrieve mimeType property of an anchor element.</p>
<p>Just as a quick preview of what’s coming, take a look at the before and after patch pictures. If it were the ad of a weight loss product we would be impressed by the change: the code has really been reduced! We don’t need to analyze anything at this point, just watch how the code was brutally trimmed. I prefer the elegance of the malware authors, even if malware. And by the way, attackers won’t get discouraged by this trim, they will instead try to find an alternative.</p>
<p><a href="https://www.brokenbrowser.com/wp-content/uploads/2016/09/before-after-1.png" title="Before and After Patch"><img loading="lazy" src="/2016/09/before-after-1.png" alt=""  />
</a></p>
<h3 id="bug-patched-finding-an-alternative">Bug patched: Finding an Alternative<a hidden class="anchor" aria-hidden="true" href="#bug-patched-finding-an-alternative">#</a></h3>
<p>So the patch is brutal but ideas start flowing. Why don’t we find an alternative route (aka variation) like real attackers do? It might be possible and worth a few minutes. So we need to get the unpatched code (from mshtml.dll in this case) and find what’s the binary function that gets hit when we access the anchor mimeType. Then, we need to find a way to call that same code using a different path.</p>
<p>The flow below shows what we guess <strong>before</strong> even disassembling mshtml. We know for sure that the yellow path exists, but we want to know if there are alternatives (red) to it. How can we do that? First, we should find the exact binary code that retrieves the mimeType, and then, uncover other references to it. The red path is a speculation, something that could or could not be there. But we will give it a try and get the answer pretty quick.</p>
<p>There is a path from the JavaScript anchor.mimeType to a binary function (compiled code) that retrieves the mimeType. Our goal is to find the binary code that retrieves the mimeType and uncover every reference to it. The red paths show references that we suspect might exist, and even if this is just a guess, it’s worth our time because it can be done in a couple of minutes.</p>
<p><a href="https://www.brokenbrowser.com/wp-content/uploads/2016/09/01-findourway.png" title="Flow"><img loading="lazy" src="/2016/09/01-findourway.png" alt="Path to mimeType"  />
</a>We will be using IDA Free for this task but there are many tools to achieve the same thing. In fact, once we get familiar with IE/Edge function names, we will go faster with a live debugger like WinDBG or even a quick disassembler like Hiew (with symbols). But today we will assume that IE is a strange object for us and we don’t know anything about it.</p>
<h3 id="setup-ida-free">Setup IDA Free<a hidden class="anchor" aria-hidden="true" href="#setup-ida-free">#</a></h3>
<p>Note: I will be posting soon how to setup IDA Free with public symbols so you can do exactly as we do here. But in the meantime I pasted <a href="http://pastebin.com/U3GqV3SV">plain-text instructions here</a> so you can get started!</p>
<h3 id="finding-the-interesting-code">Finding the Interesting Code<a hidden class="anchor" aria-hidden="true" href="#finding-the-interesting-code">#</a></h3>
<p>Let’s drop in IDA the binary that makes Internet Explorer tick: mshtml.dll. If you are not familiar with disassemblers, just follow as much as you can. This will be pretty basic and we can safely forget about opcodes today. Ready for the adventure? Remember: no Assembler required, just a bit of mind-stretching on ourselves.<br>
First Goal: find the binary code that reveals the mimeType information.</p>
<p>We know that in JavaScript, anchor.mimeType retrieves the information that we want, so let’s go straight to the Strings Tab in IDA and search for “mimeType”. We want to see what’s the code that references it. The first two matches clearly have nothing to do with our goal: MSMimeTypesCollections, MSMimeTypesCollectionsPrototype. The third one is <strong>M</strong>imeType but we want one that starts with a lowercase m. The next two are MimeTypeArray are MimeTypeArrayPrototype which again are not what we need. Next one seems to be what we are searching for! This is the first real match of “mimeType”.</p>
<p><img loading="lazy" src="/2016/09/05-mimeType-string-found.png" alt="mimeType String Found"  />
</p>
<p>Double clicking on that string takes us to the binary code tab (IDA-ViewA) which includes data references.</p>
<p><a href="https://www.brokenbrowser.com/wp-content/uploads/2016/09/06-reference-01.png" title="Code"><img loading="lazy" src="/2016/09/06-reference-01.png" alt="IDA Code View"  />
</a>IDA labels everything it can to help us with the analysis. In this case the “mimeType” string pointer was named aMimetype_2 as shown above (1). At the right (2) we can see the code that uses this string, but in order to see the complete list we should click on the label aMimeType_2 and press the “X” so a popUp will open with every line of code referencing this string. How convenient! (We know there are more references because of the three dots (3) at the right).</p>
<p>Now check out the popUp below. We have three references and the middle one seems to be the one that we need. Don’t you think so? We want to find first what’s the binary code that is hit when we access anchor.mimeType and the function names below, make sense to me.</p>
<p><a href="https://www.brokenbrowser.com/wp-content/uploads/2016/09/07-reference-02.png" title="References"><img loading="lazy" src="/2016/09/07-reference-02.png" alt="IDA References popUp"  />
</a>Remember, we are not trying to read opcodes here, just flowing with things that make sense according to the names that we know. There are more orthodox ways to achieve this but we are investing less than five minutes, just an educated guess.</p>
<p>Take a look at the names below. To me, the first one makes sense <code>CHTMLAnchorElement::Trampoline\_Get\_mimeType</code>. True that the “Trampoline” part does not look familiar, but it does not prevent us to keep going and see if we find what we need.</p>
<p><a href="https://www.brokenbrowser.com/wp-content/uploads/2016/09/08-reference-03.png" title="Trampoline_Get_mimeType"><img loading="lazy" src="/2016/09/08-reference-03.png" alt="Code Step 1"  />
</a>Entering there (double click) takes us to a longer piece of code, but we shouldn’t lose our target: mimeType. Don’t read opcodes, just find “mimeType”.</p>
<p><a href="https://www.brokenbrowser.com/wp-content/uploads/2016/09/08-reference-04.png" title="CAnchorElement::get_mimeType"><img loading="lazy" src="/2016/09/08-reference-04.png" alt="CloseToMimeType"  />
</a>Even if confusing at first sight, if we do as we said and ignore the opcodes, it’s obvious what’s the function that we should follow, right? And if we double click on CAnchorElement::get_mimeType, we will end up in the code below.</p>
<p><a href="https://www.brokenbrowser.com/wp-content/uploads/2016/09/08-reference-05.png" title="GetFileTypeInfo"><img loading="lazy" src="/2016/09/08-reference-05.png" alt="Real call to code"  />
</a>Again a bit longer than we would like, but we have CHyperlink_get_href first and a few lines below GetFileTypeInfo. It somewhat rings to me. First getting the href and then calling GetFileTypeInfo. I totally know this is a speculation but when we are analyzing regular code, educated guesses work most of the time. If we were reversing malware this would be harder, however, IE does not play tricks on us. Let’s go to GetFileTypeInfo and see what we have there.</p>
<p><a href="https://www.brokenbrowser.com/wp-content/uploads/2016/09/08-reference-06.png" title="GetFileTypeInfo"><img loading="lazy" src="/2016/09/08-reference-06.png" alt="GetFileTypeInfo"  />
</a>We found our code! The call to SHGetFileInfoW seems pretty obvious to me, but we can always <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/bb762179(v=vs.85).aspx">Google it and see what it does</a>. This seems to be the code that retrieves the mimeType, but remember we are speculating here. Let’s see if this 3 minute speculation gives us some dividends.</p>
<h3 id="finding-references-to-discover-alternative-paths">Finding References (to discover alternative paths)<a hidden class="anchor" aria-hidden="true" href="#finding-references-to-discover-alternative-paths">#</a></h3>
<p>Click once at the top, over “GetFileTypeInfo” and press the “X” to display all references. Remember: we want to see if there are other ways to hit this code.</p>
<p><a href="https://www.brokenbrowser.com/wp-content/uploads/2016/09/references.png" title="References that call GetFileTypeInfo"><img loading="lazy" src="/2016/09/references.png" alt="References that hit the code"  />
</a>### Trying JavaScript Code</p>
<p>Bingo! It seems that this code is hit twice by <em>CDocument::get_mimeType</em>, another one by <em>CImgElement::get_mimeType</em> and of course the one that we knew from the beginning, <em>CAnchorElement::get_mimeType.</em> CDocument looks like the document object to me and CImgElement seems to be the Image object or IMG HTML Tag. Of course we are speculating, but what do we lose by going right now to the browser and testing document.mimeType and Image.mimeType? I didn’t even know (or remember) that those properties existed.</p>
<p><img loading="lazy" src="/2016/09/try-js-gif.png" alt="Hitting the code using an Image"  />
</p>
<p>Rayos y centellas, Batman! It worked! Let’s see what happens with the document object. Will this work?</p>
<p><img loading="lazy" src="/2016/09/try-js-doc.png" alt="Hitting with document.mimeType"  />
</p>
<p>So now that we learned about these properties, we can complete the original flow, just like this:</p>
<p><a href="https://www.brokenbrowser.com/wp-content/uploads/2016/09/flow2-1.png" title="Flow with additional info"><img loading="lazy" src="/2016/09/flow2-1.png" alt=""  />
</a>We still don’t know if the anchorElement has other paths to the same code, but why bother? We are working with the unpatched binary and as we’ve seen at the beginning, the patched one has been seriously trimmed. In fact, a quick analysis reveals that anchorElement.mimeType and GetFileTypeInfo are not connected anymore. By “quick analysis” I mean pressing the “X” over the GetFileTypeInfo function inside IDA on the patched file. So, the updated flow really looks like this:</p>
<p><a href="https://www.brokenbrowser.com/wp-content/uploads/2016/09/patched-1.png" title="Flow of patched mshtml.dll"><img loading="lazy" src="/2016/09/patched-1.png" alt=""  />
</a>### Playing with Code Alternatives</p>
<p>We know that the anchorElement is useless for our goal but the image and document objects have chances. Well, thinking for a moment, images can’t render things other than images, so it will be better to first try using the document object which is capable of rendering images, xml, html, and more. Also, if we are going to render different content-types in a document, better not to use the one where we run our script, right? If we do, our script will be unloaded by the new content. Let’s create an iframe and play with its document.</p>
<p>We try to render a .saz (Fiddler) file right inside the iframe.</p>
<pre tabindex="0"><code>iframe = document.createElement(&#34;iframe&#34;);
iframe.src = &#34;saz.saz&#34;;  // Load a saz file
document.body.appendChild(iframe);
</code></pre><p>Damn! IE tries to download the file and throws this warning!</p>
<p><img loading="lazy" src="/2016/09/warning.png" alt="IE Warning"  />
</p>
<p>Not acceptable. Attackers are very cautious with these things. They will get caught immediately with a code like that. And in any case, it does not work: when we try to get the document.mimeType of that iframe, it returns “Chrome HTML Document”. We need to change the URL of that iframe without warnings and fool IE to think that a saz file has been rendered. We will set the location of the iframe without really changing the content of the document. This can be done with <a href="https://msdn.microsoft.com/en-us/library/hh771929(v=vs.85).aspx">history.pushState</a> or <a href="https://msdn.microsoft.com/en-us/library/hh771932(v=vs.85).aspx">history.replaceState</a>. Let’s continue with the same iframe.</p>
<pre tabindex="0"><code>iframe.contentWindow.history.pushState(&#34;&#34;,&#34;&#34;,&#34;saz.saz&#34;);
alert(iframe.contentDocument.mimeType);
</code></pre><p><a href="https://www.brokenbrowser.com/wp-content/uploads/2016/09/pushStateMimeType.png" title="First working PoC"><img loading="lazy" src="/2016/09/pushStateMimeType.png" alt="pushstatemimetype"  />
</a>It seems that we have it, right? Wrong! We’ve been lucky because the saz file was previously downloaded and cached, although not rendered because it has a saz extension. When IE requests data from a URL, it first tries to guess its content type <a href="https://msdn.microsoft.com/library/ms775147.aspx">using different mechanisms</a>, and the last of them is the file extension. In this case we are not even retrieving a valid saz file, the web-server response was a default HTTP Status Code 200 with default Content-Type: application/octet-stream but IE ended up guessing that it’s a Fiddler file because of its extension, however, it needed to download the file first.</p>
<h3 id="building-a-working-proof-of-concept">Building a working Proof of Concept<a hidden class="anchor" aria-hidden="true" href="#building-a-working-proof-of-concept">#</a></h3>
<p>So what can we do to download the file in advance without warnings? Well, there are a zillion ways, but let’s use the most primitive one which was used in the past to cache roll-over images: the Image object. Let’s build a proof of concept but this time caching the saz in advance and using replaceState instead of pushState (it’s cleaner and doesn’t add URLs in the history object).</p>
<pre tabindex="0"><code>img = new Image();
img.src = &#34;saz.saz&#34;; // HTTP 200, any length and content-type

// The saz is precached. Let&#39;s create the iframe.
iframe = document.createElement(&#34;iframe&#34;);

// Load anything inside it because about:blank does not work with replaceState.
iframe.src = &#34;/favicon.ico&#34;;
document.body.appendChild(iframe);

// Set the location of the iframe to the saz file
iframe.contentWindow.history.replaceState(&#34;&#34;, &#34;&#34;, img.src);

// Bingo!
alert(iframe.contentDocument.mimeType);
</code></pre><h4 id="update-variation-patched-on-2016-11-08httpstechnetmicrosoftcomen-uslibrarysecurityms16-novaspx">Update: variation <a href="https://technet.microsoft.com/en-us/library/security/ms16-nov.aspx">patched on 2016-11-08</a>.<a hidden class="anchor" aria-hidden="true" href="#update-variation-patched-on-2016-11-08httpstechnetmicrosoftcomen-uslibrarysecurityms16-novaspx">#</a></h4>
<h3 id="-test-it-live-on-iehttpwwwcrackingcomardemosmimetype---download-the-fileshttpsgooglkq3ybz-">[ <a href="http://www.cracking.com.ar/demos/mimetype/">Test it Live on IE</a> ] [ <a href="https://goo.gl/Kq3yBz">Download the Files</a> ]<a hidden class="anchor" aria-hidden="true" href="#-test-it-live-on-iehttpwwwcrackingcomardemosmimetype---download-the-fileshttpsgooglkq3ybz-">#</a></h3>
<p>If you are a Linux user, just watch the video below:</p>
<!-- raw HTML omitted -->
<p>Have a nice day, fellow bug hunter! If you have questions please ping me at <a href="https://twitter.com/magicmac2000">magicmac2000</a>.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="/">BrokenBrowser - Fun with browser vulnerabilities</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
